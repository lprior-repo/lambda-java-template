version: '3'

# AWS Lambda Java Template - Extreme DRY Taskfile
# Uses AWS Lambda containers for consistent native builds

vars:
  PROJECT_NAME: lambda-java-template
  AWS_REGION: us-east-1
  GRAALVM_VERSION: 21.0.2-graalce
  LAMBDA_CONTAINER: public.ecr.aws/lambda/provided:al2
  BUILD_DIR: ./build

tasks:
  default:
    desc: ğŸš€ Show available tasks
    cmds:
      - task --list

  # ğŸ§¹ Cleanup
  clean:
    desc: ğŸ§¹ Clean all build artifacts
    cmds:
      - rm -rf {{.BUILD_DIR}}
      - mvn clean -q

  # ğŸ—ï¸ Native Build (Docker Container - Like CI)
  native:
    desc: âš¡ Build GraalVM native executables using AWS Lambda container
    deps: [clean]
    cmds:
      - echo "ğŸš€ Building native executables in AWS Lambda container..."
      - docker pull {{.LAMBDA_CONTAINER}}
      - |
        docker run --rm \
          --entrypoint="" \
          -v "$(pwd)":/workspace \
          -w /workspace \
          {{.LAMBDA_CONTAINER}} \
          bash -c "
            yum update -y && \
            yum install -y tar gzip which unzip zip gcc gcc-c++ glibc-devel zlib-devel && \
            curl -s 'https://get.sdkman.io' | bash && \
            source ~/.sdkman/bin/sdkman-init.sh && \
            sdk install java {{.GRAALVM_VERSION}} && \
            sdk install maven && \
            export JAVA_HOME=~/.sdkman/candidates/java/current && \
            export PATH=\$JAVA_HOME/bin:\$PATH && \
            ./scripts/build.sh
          "

  # ğŸ—ï¸ Build JARs only (for testing)
  jar:
    desc: ğŸ“¦ Build JAR packages only
    cmds:
      - mvn clean package -DskipTests -q

  # ğŸ§ª Test
  test:
    desc: ğŸ§ª Run all tests
    cmds:
      - mvn test

  test:unit:
    desc: ğŸ§ª Run unit tests only
    cmds:
      - mvn test -Dtest=*Test

  test:integration:
    desc: ğŸ§ª Run integration tests only
    cmds:
      - mvn test -Dtest=*IntegrationTest

  # ğŸ—ï¸ Infrastructure
  tf:init:
    desc: ğŸ—ï¸ Initialize Terraform
    dir: terraform
    cmds:
      - terraform init

  tf:plan:
    desc: ğŸ“‹ Plan Terraform changes
    dir: terraform
    deps: [tf:init]
    cmds:
      - terraform plan

  tf:apply:
    desc: ğŸš€ Apply Terraform changes
    dir: terraform
    deps: [native]
    cmds:
      - terraform apply -auto-approve

  tf:destroy:
    desc: ğŸ’¥ Destroy infrastructure
    dir: terraform
    cmds:
      - terraform destroy -auto-approve

  tf:validate:
    desc: âœ… Validate Terraform
    dir: terraform
    deps: [tf:init]
    cmds:
      - terraform validate
      - terraform fmt -check

  # ğŸ§ª Infrastructure Testing
  terratest:
    desc: ğŸ§ª Run Terratest infrastructure tests
    dir: infra-tests
    deps: [tf:apply]
    cmds:
      - go mod tidy
      - go test -v -timeout 15m -run TestLambdaIntegration

  # ğŸš€ Full Deployment
  deploy:
    desc: ğŸš€ Full deployment (native + infrastructure)
    cmds:
      - task: native
      - task: tf:apply

  deploy:dev:
    desc: ğŸš€ Deploy to development
    env:
      TF_VAR_environment: dev
    cmds:
      - task: deploy

  # ğŸ“Š Monitoring
  logs:
    desc: ğŸ“Š View Lambda logs
    cmds:
      - aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/{{.PROJECT_NAME}}" --query 'logGroups[*].logGroupName'

  # ğŸ§¹ Complete cleanup
  nuke:
    desc: ğŸ’¥ Complete cleanup (destroy + clean)
    cmds:
      - task: tf:destroy
      - task: clean
      - docker system prune -f

  # ğŸƒ Local Development & Debugging
  dev:local:
    desc: ğŸƒ Start local development environment
    cmds:
      - echo "ğŸš€ Starting local development environment..."
      - docker-compose -f docker-compose.local.yml up -d
      - sleep 5
      - ./scripts/setup-local-dynamodb.sh
      - echo "âœ… Local environment ready! Run 'task dev:run' to start the app"

  dev:run:
    desc: ğŸ”¥ Run Spring Boot app locally for debugging (with hot reload)
    dir: src/product-service
    cmds:
      - echo "ğŸ”¥ Starting Spring Boot app with hot reload..."
      - echo "ğŸŒ App will be available at http://localhost:8080/api/products"
      - echo "ğŸ”§ Set breakpoints in your IDE and attach debugger to port 5005"
      - mvn spring-boot:run -Dspring-boot.run.profiles=local -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005"

  dev:debug:
    desc: ğŸ› Run with remote debugging enabled (suspends until debugger attached)
    dir: src/product-service
    cmds:
      - echo "ğŸ› Starting with remote debugging (waiting for debugger)..."
      - echo "ğŸ”Œ Attach your IDE debugger to localhost:5005"
      - mvn spring-boot:run -Dspring-boot.run.profiles=local -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"

  dev:test:
    desc: ğŸ§ª Test local API endpoints
    cmds:
      - echo "ğŸ§ª Testing local API endpoints..."
      - echo "ğŸ“Š Health check:"
      - curl -s http://localhost:8080/api/health || echo "âŒ Service not running"
      - echo ""
      - echo "ğŸ“¦ Get products:"
      - curl -s http://localhost:8080/api/products | jq '.' || echo "âŒ Products endpoint failed"

  dev:stop:
    desc: ğŸ›‘ Stop local development environment
    cmds:
      - echo "ğŸ›‘ Stopping local development environment..."
      - docker-compose -f docker-compose.local.yml down
      - echo "âœ… Local environment stopped"

  dev:clean:
    desc: ğŸ§¹ Clean local development data
    cmds:
      - echo "ğŸ§¹ Cleaning local development data..."
      - docker-compose -f docker-compose.local.yml down -v
      - docker volume prune -f
      - rm -rf local-data/
      - echo "âœ… Local data cleaned"

  # ğŸƒ Full Development workflow
  dev:
    desc: ğŸƒ Full development workflow (test + native + deploy)
    cmds:
      - task: test
      - task: deploy:dev