version: '3'

# Serverless Acceleration Platform - Java Template
# Velocity First: Ship with Confidence & Discipline

vars:
  PROJECT_NAME: lambda-java-template
  AWS_REGION: us-east-1
  ENVIRONMENT: dev
  JAVA_VERSION: 21
  MAVEN_OPTS: -Xmx2g

env:
  AWS_REGION: "{{.AWS_REGION}}"
  MAVEN_OPTS: "{{.MAVEN_OPTS}}"

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list-all

  # üöÄ Velocity First: Build & Package
  deps:
    desc: Download Maven dependencies
    cmds:
      - mvn dependency:resolve dependency:resolve-sources
    sources:
      - pom.xml

  compile:
    desc: Compile Java sources
    deps: [deps]
    cmds:
      - mvn compile
    sources:
      - src/main/**/*.java
      - pom.xml
    generates:
      - target/classes/**

  build:
    desc: Build and package Java Lambda functions
    deps: [compile]
    cmds:
      - mvn package -DskipTests
    sources:
      - src/main/**/*.java
      - pom.xml
    generates:
      - target/*.jar

  package:
    desc: Package Lambda functions for deployment
    deps: [build]
    cmds:
      - mkdir -p build
      - |
        # Auto-discover and copy service JARs
        for service_dir in src/*/; do
          service_name=$(basename "$service_dir")
          jar_file="$service_dir/target/$service_name.jar"
          if [ -f "$jar_file" ]; then
            cp "$jar_file" build/
            echo "‚úÖ Packaged: $service_name.jar"
          fi
        done
        # Also check for any existing JAR files in main target
        if [ -f "target/lambda-java-template.jar" ]; then
          cp target/lambda-java-template.jar build/
          echo "‚úÖ Packaged: lambda-java-template.jar"
        fi
        echo "üì¶ All Lambda JARs ready in build/ directory"
        ls -la build/*.jar 2>/dev/null || echo "‚ö†Ô∏è  No JAR files found"
    sources:
      - target/*.jar
      - src/*/target/*.jar
    generates:
      - build/*.jar

  # üß™ Test-First: Build with Quality
  test:
    desc: Run all tests with coverage
    deps: [compile]
    cmds:
      - mvn test jacoco:report
      - echo "üìä Coverage report: target/site/jacoco/index.html"

  test:unit:
    desc: Run unit tests only
    deps: [compile]
    cmds:
      - mvn test -Dtest="**/*Test"

  test:integration:
    desc: Run integration tests
    deps: [compile]
    cmds:
      - mvn test -Dtest="**/*IT"

  test:watch:
    desc: Run tests in watch mode for TDD
    deps: [compile]
    cmds:
      - |
        if command -v watchexec >/dev/null 2>&1; then
          watchexec -e java,xml -- mvn test-compile test
        else
          echo "‚ö†Ô∏è  Install watchexec for watch mode: brew install watchexec"
          echo "üìã Run 'mvn test' manually after changes"
        fi

  test:coverage:
    desc: Generate detailed test coverage report
    deps: [test]
    cmds:
      - mvn jacoco:report
      - echo "üìä Coverage report: target/site/jacoco/index.html"
      - |
        if command -v open >/dev/null 2>&1; then
          open target/site/jacoco/index.html
        fi

  # üìä Observability First: Ship with Insight
  logs:
    desc: Tail Lambda function logs
    cmds:
      - aws logs tail /aws/lambda/{{.PROJECT_NAME}}-hello --follow

  logs:hello:
    desc: Get hello function logs with JSON formatting
    cmds:
      - echo "üìã Latest log streams for hello function:"
      - aws logs describe-log-streams --log-group-name /aws/lambda/{{.PROJECT_NAME}}-hello --order-by LastEventTime --descending --max-items 5
      - echo "üìù Recent structured log events:"
      - aws logs get-log-events --log-group-name /aws/lambda/{{.PROJECT_NAME}}-hello --log-stream-name $(aws logs describe-log-streams --log-group-name /aws/lambda/{{.PROJECT_NAME}}-hello --order-by LastEventTime --descending --max-items 1 --query 'logStreams[0].logStreamName' --output text) --limit 50

  logs:users:
    desc: Get users function logs with JSON formatting
    cmds:
      - echo "üìã Latest log streams for users function:"
      - aws logs describe-log-streams --log-group-name /aws/lambda/{{.PROJECT_NAME}}-users --order-by LastEventTime --descending --max-items 5
      - echo "üìù Recent structured log events:"
      - aws logs get-log-events --log-group-name /aws/lambda/{{.PROJECT_NAME}}-users --log-stream-name $(aws logs describe-log-streams --log-group-name /aws/lambda/{{.PROJECT_NAME}}-users --order-by LastEventTime --descending --max-items 1 --query 'logStreams[0].logStreamName' --output text) --limit 50

  xray:
    desc: View X-Ray traces and service map
    cmds:
      - echo "üîç X-Ray Service Map: https://{{.AWS_REGION}}.console.aws.amazon.com/xray/home?region={{.AWS_REGION}}#/service-map"
      - echo "üìä X-Ray Traces: https://{{.AWS_REGION}}.console.aws.amazon.com/xray/home?region={{.AWS_REGION}}#/traces"
      - echo "‚ö° Performance Insights: https://{{.AWS_REGION}}.console.aws.amazon.com/lambda/home?region={{.AWS_REGION}}#/functions"

  metrics:
    desc: View CloudWatch metrics dashboard
    cmds:
      - echo "üìä CloudWatch Dashboard: https://{{.AWS_REGION}}.console.aws.amazon.com/cloudwatch/home?region={{.AWS_REGION}}#dashboards:name={{.PROJECT_NAME}}"
      - echo "‚òï JVM Metrics: Memory, GC, Thread usage available in CloudWatch"

  # üèóÔ∏è Infrastructure as Code
  tf:init:
    desc: Initialize Terraform
    dir: terraform
    cmds:
      - terraform init

  tf:plan:
    desc: Plan Terraform changes
    dir: terraform
    deps: [tf:init]
    cmds:
      - terraform plan -var="environment={{.ENVIRONMENT}}"

  tf:apply:
    desc: Apply Terraform changes
    dir: terraform
    deps: [package]
    cmds:
      - terraform apply -var="environment={{.ENVIRONMENT}}" -auto-approve

  tf:destroy:
    desc: Destroy Terraform infrastructure
    dir: terraform
    cmds:
      - terraform destroy -var="environment={{.ENVIRONMENT}}" -auto-approve

  # üîê OIDC Bootstrap
  bootstrap:
    desc: Bootstrap OIDC for GitHub Actions deployment
    dir: terraform
    deps: [tf:init]
    cmds:
      - |
        echo "üöÄ Bootstrapping OIDC infrastructure..."
        read -p "GitHub Organization: " GITHUB_ORG
        read -p "GitHub Repository: " GITHUB_REPO
        read -p "Create new OIDC provider? (y/n): " CREATE_OIDC
        CREATE_OIDC_BOOL=$([ "$CREATE_OIDC" = "y" ] && echo "true" || echo "false")
        terraform plan \
          -var="github_org=$GITHUB_ORG" \
          -var="github_repo=$GITHUB_REPO" \
          -var="create_oidc_provider=$CREATE_OIDC_BOOL" \
          -var="environment={{.ENVIRONMENT}}" \
          -out=bootstrap.tfplan
        echo ""
        echo "üìã Review the plan above. Continue? (y/n)"
        read -p "> " CONTINUE
        if [ "$CONTINUE" = "y" ]; then
          terraform apply bootstrap.tfplan
          echo ""
          echo "‚úÖ OIDC infrastructure created!"
          echo "üîß Bootstrap script generated at: scripts/bootstrap-oidc.sh"
          echo "üìÑ Run the script to generate GitHub Actions workflow"
        else
          echo "‚ùå Bootstrap cancelled"
        fi

  tf:validate:
    desc: Validate Terraform configuration
    dir: terraform
    cmds:
      - terraform validate
      - terraform fmt -check

  tf:security:
    desc: Run security checks on Terraform
    dir: terraform
    cmds:
      - |
        if command -v tfsec >/dev/null 2>&1; then
          tfsec .
        else
          echo "‚ö†Ô∏è  tfsec not installed. Install with: brew install tfsec"
        fi

  # üõ°Ô∏è Well-Architected: Ship with Excellence
  lint:
    desc: Run Java code quality checks
    deps: [compile]
    cmds:
      - mvn checkstyle:check
      - mvn spotbugs:check
      - mvn pmd:check

  lint:fix:
    desc: Auto-fix code formatting issues
    cmds:
      - mvn spotless:apply

  security:
    desc: Run security audit and vulnerability scanning
    deps: [compile]
    cmds:
      - mvn dependency-check:check
      - |
        if mvn help:describe -Dplugin=com.github.spotbugs:spotbugs-maven-plugin >/dev/null 2>&1; then
          mvn spotbugs:spotbugs
        fi

  analyze:
    desc: Run static code analysis
    deps: [compile]
    cmds:
      - mvn sonar:sonar -Dsonar.host.url=http://localhost:9000 || echo "‚ö†Ô∏è  SonarQube not available"
      - mvn site

  validate:
    desc: Run all validation checks
    deps: [compile]
    cmds:
      - task: lint
      - task: test
      - task: security
      - task: tf:validate
      - task: tf:security

  validate:prod-ready:
    desc: Comprehensive production readiness validation
    cmds:
      - echo "üîç Starting production readiness validation..."
      - task: validate
      - task: test:coverage
      - task: validate:powertools
      - task: validate:monitoring
      - task: validate:native
      - echo "‚úÖ Production readiness validation completed!"

  validate:powertools:
    desc: Validate AWS Lambda Powertools integration
    cmds:
      - echo "üîß Validating Lambda Powertools integration..."
      - |
        # Auto-discover services and validate each
        for service_dir in src/*/; do
          service_name=$(basename "$service_dir")
          if [ -d "$service_dir/src/" ]; then
            echo "üì¶ Validating $service_name..."
            grep -r "@Logging" "$service_dir/src/" || echo "‚ùå Missing @Logging annotations in $service_name"
            grep -r "@Tracing" "$service_dir/src/" || echo "‚ùå Missing @Tracing annotations in $service_name" 
            grep -r "TracingUtils" "$service_dir/src/" || echo "‚ùå Missing TracingUtils usage in $service_name"
            grep -r "MDC" "$service_dir/src/" || echo "‚ùå Missing structured logging in $service_name"
          fi
        done
      - echo "‚úÖ Lambda Powertools validation completed"

  validate:monitoring:
    desc: Validate CloudWatch monitoring setup
    cmds:
      - echo "üìä Validating CloudWatch monitoring setup..."
      - test -f terraform/cloudwatch.tf || echo "‚ùå Missing CloudWatch configuration"
      - grep -q "aws_cloudwatch_dashboard" terraform/cloudwatch.tf || echo "‚ùå Missing CloudWatch dashboards"
      - grep -q "aws_cloudwatch_metric_alarm" terraform/cloudwatch.tf || echo "‚ùå Missing CloudWatch alarms"
      - grep -q "aws_sns_topic" terraform/cloudwatch.tf || echo "‚ùå Missing SNS alerts"
      - echo "‚úÖ CloudWatch monitoring validation completed"

  validate:native:
    desc: Validate GraalVM native build capabilities
    cmds:
      - echo "üèóÔ∏è Validating GraalVM native build setup..."
      - test -f build-graalvm-native.sh || echo "‚ùå Missing native build script"
      - grep -q "native-maven-plugin" pom.xml || echo "‚ùå Missing native Maven plugin"
      - grep -q "graalvm" .github/workflows/ci.yml || echo "‚ùå Missing GraalVM in CI pipeline"
      - echo "‚úÖ GraalVM native build validation completed"

  # üöÄ Deployment Pipeline
  deploy:dev:
    desc: Deploy to development environment
    cmds:
      - task: validate
      - task: build
      - task: package
      - ./scripts/deploy-lambda.sh --jvm --test

  deploy:staging:
    desc: Deploy to staging environment
    cmds:
      - task: validate
      - task: build
      - task: package
      - ./scripts/deploy-lambda.sh --jvm

  deploy:prod:
    desc: Deploy to production environment
    cmds:
      - task: validate
      - task: build
      - task: package
      - ./scripts/deploy-lambda.sh --jvm

  deploy:native:
    desc: Deploy native GraalVM functions
    cmds:
      - task: validate
      - task: graalvm:compile
      - ./scripts/deploy-lambda.sh --native --test

  deploy:lambda:
    desc: Deploy Lambda function code only (JVM)
    deps: [build, package]
    cmds:
      - ./scripts/deploy-lambda.sh --jvm

  deploy:lambda:native:
    desc: Deploy Lambda function code only (Native)
    deps: [graalvm:compile]
    cmds:
      - ./scripts/deploy-lambda.sh --native

  # üßπ Cleanup
  clean:
    desc: Clean build artifacts
    cmds:
      - mvn clean
      - rm -rf build/

  clean:tf:
    desc: Clean Terraform state (DANGEROUS)
    dir: terraform
    cmds:
      - rm -rf .terraform/
      - rm -f .terraform.lock.hcl
      - rm -f terraform.tfstate*

  # üîç Development Tools
  dev:setup:
    desc: Setup Java development environment
    cmds:
      - java --version
      - mvn --version
      - task: deps
      - task: tf:init
      - echo "‚úÖ Java development environment ready!"
      - echo "‚òï Java version: {{.JAVA_VERSION}}"
      - echo "üèóÔ∏è  Maven configured with {{.MAVEN_OPTS}}"
      - echo "üí° Run 'task test:watch' for TDD workflow"
      - echo "üöÄ Run 'task deploy:dev' to deploy"

  dev:tools:
    desc: Install Java development tools
    cmds:
      - |
        echo "üõ†Ô∏è Java development tools available:"
        echo "‚Ä¢ SpotBugs: Static analysis for bugs"
        echo "‚Ä¢ Checkstyle: Code style checking"
        echo "‚Ä¢ PMD: Source code analyzer"
        echo "‚Ä¢ JaCoCo: Code coverage"
        echo "‚Ä¢ OWASP Dependency Check: Security vulnerabilities"

  dev:invoke:
    desc: Invoke Lambda function locally using SAM
    deps: [package]
    cmds:
      - |
        echo "üß™ Invoking hello function locally..."
        if command -v sam >/dev/null 2>&1; then
          sam local invoke HelloFunction --event events/api-gateway-event.json
        else
          echo "‚ö†Ô∏è  AWS SAM CLI not installed"
        fi

  dev:debug:
    desc: Start Lambda function in debug mode
    deps: [package]
    cmds:
      - |
        echo "üêõ Starting debug mode on port 5858..."
        if command -v sam >/dev/null 2>&1; then
          sam local start-api --debug-port 5858
        else
          echo "‚ö†Ô∏è  AWS SAM CLI not installed"
        fi

  api:docs:
    desc: Generate API documentation from OpenAPI spec
    cmds:
      - |
        if command -v redoc-cli >/dev/null 2>&1; then
          redoc-cli build openapi.yaml --output docs/api.html
          echo "üìö API documentation generated: docs/api.html"
        else
          echo "‚ö†Ô∏è  redoc-cli not installed. Run: npm install -g redoc-cli"
        fi

  api:validate:
    desc: Validate OpenAPI specification
    cmds:
      - |
        if command -v swagger-codegen >/dev/null 2>&1; then
          swagger-codegen validate -i openapi.yaml
        else
          echo "‚ö†Ô∏è  swagger-codegen not installed"
          echo "üìù OpenAPI spec located at: openapi.yaml"
        fi

  # üìä Performance Analysis
  profile:
    desc: Run JVM profiling
    deps: [package]
    cmds:
      - echo "üî¨ JVM profiling available through:"
      - echo "‚Ä¢ CloudWatch JVM metrics (automatic)"
      - echo "‚Ä¢ X-Ray performance traces"
      - echo "‚Ä¢ JFR (Java Flight Recorder) for detailed analysis"

  benchmark:
    desc: Run performance benchmarks
    deps: [compile]
    cmds:
      - mvn test -Dtest="**/*Benchmark"

  # üìä Well-Architected Review
  review:
    desc: Open Well-Architected review document
    cmds:
      - |
        if [ -f "WELL_ARCHITECTED.md" ]; then
          echo "üìã Opening Well-Architected review..."
          open WELL_ARCHITECTED.md 2>/dev/null || echo "üìÑ Review document: WELL_ARCHITECTED.md"
        else
          echo "‚ùå WELL_ARCHITECTED.md not found. Run 'task generate:docs' first."
        fi

  generate:docs:
    desc: Generate project documentation
    cmds:
      - task: api:docs
      - task: test:coverage
      - mvn site
      - echo "üìö Documentation generated successfully!"
      - echo "üìä Coverage report: target/site/jacoco/index.html"
      - echo "üìö API docs: docs/api.html"
      - echo "üèóÔ∏è  Maven site: target/site/index.html"

  # üîß Advanced Java Tools
  graalvm:setup:
    desc: Setup GraalVM for native compilation
    cmds:
      - |
        echo "üöÄ GraalVM Native Image setup:"
        echo "1. Install GraalVM: sdk install java 17.0.8-graal"
        echo "2. Install native-image: gu install native-image"
        echo "3. Run: task graalvm:compile"

  graalvm:compile:
    desc: Compile to native image with GraalVM
    deps: [package]
    cmds:
      - |
        if command -v native-image >/dev/null 2>&1; then
          echo "üî® Compiling to native image..."
          native-image -jar build/hello-lambda.jar build/hello-native
          echo "‚úÖ Native image: build/hello-native"
        else
          echo "‚ö†Ô∏è  GraalVM native-image not available"
        fi

  # üå± Ephemeral Development Environment
  ephemeral:start:
    desc: Create and deploy ephemeral development environment
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        echo "üå± Starting ephemeral environment for developer: $DEVELOPER_ID, branch: $BRANCH_NAME"
        cd terraform
        terraform init
        terraform plan -var-file=environments/ephemeral.tfvars -var="developer_id=$DEVELOPER_ID" -var="branch_name=$BRANCH_NAME"
        terraform apply -var-file=environments/ephemeral.tfvars -var="developer_id=$DEVELOPER_ID" -var="branch_name=$BRANCH_NAME" -auto-approve
        echo "‚úÖ Ephemeral environment ready!"

  ephemeral:status:
    desc: Check status of ephemeral environment
    dir: terraform
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        echo "üîç Checking ephemeral environment for developer: $DEVELOPER_ID, branch: $BRANCH_NAME"
        terraform show -json | jq -r '.values.outputs | to_entries[] | select(.key | startswith("ephemeral")) | "\(.key): \(.value.value)"'

  ephemeral:deploy:
    desc: Deploy code to existing ephemeral environment (JVM mode for fast development)
    deps: [build, package]
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        ENV_PREFIX="lambda-java-template-ephemeral-$DEVELOPER_ID-$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9-]/-/g')"
        echo "üöÄ Deploying to ephemeral environment: $ENV_PREFIX"
        aws lambda update-function-code --function-name "$ENV_PREFIX-hello" --zip-file fileb://build/hello-lambda.jar || echo "Function not found - run ephemeral:start first"

  ephemeral:logs:
    desc: View logs from ephemeral environment
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        ENV_PREFIX="lambda-java-template-ephemeral-$DEVELOPER_ID-$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9-]/-/g')"
        LOG_GROUP="/aws/lambda/$ENV_PREFIX-hello"
        echo "üìã Viewing logs for: $LOG_GROUP"
        aws logs tail "$LOG_GROUP" --follow

  ephemeral:destroy:
    desc: Destroy ephemeral development environment
    dir: terraform
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        echo "üóëÔ∏è Destroying ephemeral environment for developer: $DEVELOPER_ID, branch: $BRANCH_NAME"
        terraform destroy -var-file=environments/ephemeral.tfvars -var="developer_id=$DEVELOPER_ID" -var="branch_name=$BRANCH_NAME" -auto-approve
        echo "‚úÖ Ephemeral environment destroyed!"

  ephemeral:test:
    desc: Run tests against ephemeral environment
    cmds:
      - |
        DEVELOPER_ID="${DEVELOPER_ID:-$(whoami)}"
        BRANCH_NAME="${BRANCH_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)}"
        ENV_PREFIX="lambda-java-template-ephemeral-$DEVELOPER_ID-$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9-]/-/g')"
        echo "üß™ Running tests against ephemeral environment: $ENV_PREFIX"
        API_ENDPOINT=$(cd terraform && terraform output -raw ephemeral_api_endpoint 2>/dev/null || echo "not-found")
        if [ "$API_ENDPOINT" != "not-found" ]; then
          curl -f "$API_ENDPOINT/hello" && echo "\n‚úÖ Ephemeral environment is responding"
        else
          echo "‚ùå Could not find ephemeral environment endpoint"
        fi