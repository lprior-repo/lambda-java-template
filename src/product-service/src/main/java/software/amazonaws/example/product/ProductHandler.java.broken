package software.amazonaws.example.product;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.lambda.powertools.logging.Logging;
import software.amazon.lambda.powertools.metrics.Metrics;
import software.amazon.lambda.powertools.tracing.Tracing;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

// Structured logging with Powertools v2 using MDC

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class ProductHandler implements RequestHandler<APIGatewayV2HTTPEvent, APIGatewayV2HTTPResponse> {
    private static final Logger LOGGER = LoggerFactory.getLogger(ProductHandler.class);
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
    private static final String TABLE_NAME = System.getenv("PRODUCTS_TABLE_NAME");

    private final ProductService productService;

    public ProductHandler() {
        DynamoDbClient dynamoDbClient = DynamoDbClient.builder().build();
        ProductRepository productRepository = new ProductRepository(dynamoDbClient, TABLE_NAME);
        this.productService = new ProductService(productRepository);
    }

    // Constructor for testing
    public ProductHandler(ProductService productService) {
        this.productService = productService;
    }

    @Override
    @Logging(logEvent = true, correlationIdPath = "/requestContext/requestId")
    @Tracing
    public APIGatewayV2HTTPResponse handleRequest(APIGatewayV2HTTPEvent request, Context context) {
        try {
            String httpMethod = request != null && request.getRequestContext() != null && request.getRequestContext().getHttp() != null
                ? request.getRequestContext().getHttp().getMethod() : null;
            String path = request != null && request.getRequestContext() != null && request.getRequestContext().getHttp() != null
                ? request.getRequestContext().getHttp().getPath() : null;

            // Add structured logging context with Powertools v2 using MDC
            MDC.put("httpMethod", httpMethod);
            MDC.put("path", path);
            MDC.put("requestId", context.getAwsRequestId());
            MDC.put("functionName", context.getFunctionName());
            MDC.put("functionVersion", context.getFunctionVersion());
            
            // Add business context
            if (request.getHeaders() != null) {
                MDC.put("userAgent", request.getHeaders().get("user-agent"));
                MDC.put("sourceIp", request.getHeaders().get("x-forwarded-for"));
            }

            LOGGER.info("Processing API request - operation: handleRequest, httpMethod: {}, path: {}", 
                httpMethod, path);

            if (httpMethod == null) {
                LOGGER.error("HTTP method is null in request", 
                    //entry("error", "missing_http_method"), 
                    //entry("requestId", context.getAwsRequestId()));
                return createErrorResponse(400, "Bad Request", "HTTP method not found in request");
            }

            return switch (httpMethod) {
                case "GET" -> handleGetRequest(request, context, path);
                case "POST" -> handleCreateProduct(request, context);
                case "PUT" -> handleUpdateProduct(request, context);
                case "DELETE" -> handleDeleteProduct(request, context);
                default -> {
                    LOGGER.warn("Unsupported HTTP method", 
                        //entry("httpMethod", httpMethod), 
                        //entry("supportedMethods", "GET,POST,PUT,DELETE"));
                    yield createErrorResponse(405, "Method Not Allowed", "HTTP method not supported");
                }
            };

        } catch (Exception e) {
            // Enhanced error logging with Powertools v2
            MDC.put("error", e.getClass().getSimpleName());
            MDC.put("errorMessage", e.getMessage());
            
            LOGGER.error("Error processing request", 
                //entry("error", e.getClass().getSimpleName()),
                //entry("errorMessage", e.getMessage()),
                //entry("requestId", context.getAwsRequestId()), e);
            return createErrorResponse(500, "Internal Server Error", "An unexpected error occurred");
        } finally {
            // Clean up logging context (clear all custom keys)
            MDC.clear();
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleGetRequest(APIGatewayV2HTTPEvent request, Context context, String path) {
        // Route based on path (remove stage prefix if present)
        String normalizedPath = path;
        if (path != null && path.startsWith("/prod/")) {
            normalizedPath = path.substring(5); // Remove "/prod"
        }

        MDC.put("normalizedPath", normalizedPath);
        LOGGER.info("Routing GET request", 
            //entry("operation", "handleGetRequest"),
            //entry("originalPath", path),
            //entry("normalizedPath", normalizedPath));

        if (normalizedPath != null && normalizedPath.equals("/health")) {
            return handleHealthCheck(request, context);
        } else if (normalizedPath != null && normalizedPath.startsWith("/products/")) {
            return handleGetProduct(request, context);
        } else if (normalizedPath != null && normalizedPath.equals("/products")) {
            return handleListProducts(request, context);
        } else {
            LOGGER.warn("Endpoint not found", 
                //entry("operation", "routeNotFound"), 
                //entry("normalizedPath", normalizedPath),
                //entry("availableEndpoints", "/health, /products, /products/{id}"));
            return createErrorResponse(404, "Not Found", "Endpoint not found: " + normalizedPath);
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleHealthCheck(APIGatewayV2HTTPEvent request, Context context) {
        LOGGER.info("Processing health check", 
            //entry("operation", "healthCheck"),
            //entry("endpoint", "/health"));
        Map<String, Object> healthResponse = Map.of(
            "status", "healthy",
            "timestamp", java.time.Instant.now().toString(),
            "service", "product-service",
            "runtime", "java21"
        );
        return createSuccessResponse(200, healthResponse);
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleListProducts(APIGatewayV2HTTPEvent request, Context context) {
        try {
            LOGGER.info("Listing all products", 
                //entry("operation", "listProducts"),
                //entry("endpoint", "/products"));
            
            ProductListResponse productList = productService.getAllProducts();
            
            LOGGER.info("Successfully retrieved products", 
                //entry("operation", "listProducts"),
                //entry("productCount", productList.getProducts().size()));
            
            return createSuccessResponse(200, productList);
        } catch (Exception e) {
            MDC.put("error", e.getClass().getSimpleName());
            LOGGER.error("Error listing products", 
                //entry("operation", "listProducts"),
                //entry("error", e.getClass().getSimpleName()),
                //entry("errorMessage", e.getMessage()), e);
            return createErrorResponse(500, "Internal Server Error", "Failed to list products");
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleGetProduct(APIGatewayV2HTTPEvent request, Context context) {
        try {
            String path = request.getRequestContext().getHttp().getPath();
            String normalizedPath = path;
            if (path != null && path.startsWith("/prod/")) {
                normalizedPath = path.substring(5); // Remove "/prod"
            }
            String productId = extractProductIdFromPath(normalizedPath);
            if (productId == null) {
                LOGGER.warn("Product ID validation failed", 
                    //entry("operation", "getProduct"),
                    //entry("error", "invalid_product_id"),
                    //entry("path", normalizedPath));
                return createErrorResponse(400, "Bad Request", "Product ID is required");
            }

            MDC.put("productId", productId);
            LOGGER.info("Retrieving product", 
                //entry("operation", "getProduct"),
                //entry("productId", productId));

            Optional<ProductResponse> product = productService.getProduct(productId);
            if (product.isEmpty()) {
                LOGGER.warn("Product not found", 
                    //entry("operation", "getProduct"),
                    //entry("productId", productId),
                    //entry("result", "not_found"));
                return createErrorResponse(404, "Not Found", "Product not found");
            }

            LOGGER.info("Product retrieved successfully", 
                Map.of("operation", "getProduct",
                       "productId", productId,
                       "result", "success"));
            return createSuccessResponse(200, product.get());

        } catch (IllegalArgumentException e) {
            LOGGER.warn("Invalid product request", 
                Map.of("operation", "getProduct",
                       "error", "validation_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", e.getMessage());
        } catch (Exception e) {
            MDC.put("error", e.getClass().getSimpleName());
            LOGGER.error("Error retrieving product", 
                Map.of("operation", "getProduct",
                       "error", e.getClass().getSimpleName(),
                       "errorMessage", e.getMessage()), e);
            return createErrorResponse(500, "Internal Server Error", "Failed to retrieve product");
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleCreateProduct(APIGatewayV2HTTPEvent request, Context context) {
        try {
            CreateProductRequest createRequest = OBJECT_MAPPER.readValue(request.getBody(), CreateProductRequest.class);

            MDC.put("productName", createRequest.getName());
            MDC.put("productPrice", createRequest.getPrice().toString());
            
            LOGGER.info("Creating product", 
                Map.of("operation", "createProduct",
                       "productName", createRequest.getName(),
                       "productPrice", createRequest.getPrice()));

            ProductResponse response = productService.createProduct(createRequest);

            MDC.put("createdProductId", response.getId());
            LOGGER.info("Product created successfully", 
                Map.of("operation", "createProduct",
                       "productId", response.getId(),
                       "productName", response.getName(),
                       "result", "success"));

            return createSuccessResponse(201, response);

        } catch (JsonProcessingException e) {
            LOGGER.warn("Invalid JSON format in create request", 
                Map.of("operation", "createProduct",
                       "error", "json_parsing_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", "Invalid JSON format");
        } catch (IllegalArgumentException e) {
            LOGGER.warn("Validation error in create request", 
                Map.of("operation", "createProduct",
                       "error", "validation_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", e.getMessage());
        } catch (Exception e) {
            MDC.put("error", e.getClass().getSimpleName());
            LOGGER.error("Error creating product", 
                Map.of("operation", "createProduct",
                       "error", e.getClass().getSimpleName(),
                       "errorMessage", e.getMessage()), e);
            return createErrorResponse(500, "Internal Server Error", "Failed to create product");
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleUpdateProduct(APIGatewayV2HTTPEvent request, Context context) {
        try {
            String path = request.getRequestContext().getHttp().getPath();
            String normalizedPath = path;
            if (path != null && path.startsWith("/prod/")) {
                normalizedPath = path.substring(5); // Remove "/prod"
            }
            String productId = extractProductIdFromPath(normalizedPath);
            if (productId == null) {
                LOGGER.warn("Product ID validation failed in update", 
                    Map.of("operation", "updateProduct",
                           "error", "invalid_product_id",
                           "path", normalizedPath));
                return createErrorResponse(400, "Bad Request", "Product ID is required");
            }

            UpdateProductRequest updateRequest = OBJECT_MAPPER.readValue(request.getBody(), UpdateProductRequest.class);
            
            MDC.put("productId", productId);
            MDC.put("productName", updateRequest.getName());
            MDC.put("productPrice", updateRequest.getPrice().toString());
            
            LOGGER.info("Updating product", 
                Map.of("operation", "updateProduct",
                       "productId", productId,
                       "productName", updateRequest.getName(),
                       "productPrice", updateRequest.getPrice()));
            
            Optional<ProductResponse> response = productService.updateProduct(productId, updateRequest);

            if (response.isEmpty()) {
                LOGGER.warn("Product not found for update", 
                    Map.of("operation", "updateProduct",
                           "productId", productId,
                           "result", "not_found"));
                return createErrorResponse(404, "Not Found", "Product not found");
            }

            LOGGER.info("Product updated successfully", 
                Map.of("operation", "updateProduct",
                       "productId", productId,
                       "result", "success"));
            return createSuccessResponse(200, response.get());

        } catch (JsonProcessingException e) {
            LOGGER.warn("Invalid JSON format in update request", 
                Map.of("operation", "updateProduct",
                       "error", "json_parsing_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", "Invalid JSON format");
        } catch (IllegalArgumentException e) {
            LOGGER.warn("Validation error in update request", 
                Map.of("operation", "updateProduct",
                       "error", "validation_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", e.getMessage());
        } catch (Exception e) {
            MDC.put("error", e.getClass().getSimpleName());
            LOGGER.error("Error updating product", 
                Map.of("operation", "updateProduct",
                       "error", e.getClass().getSimpleName(),
                       "errorMessage", e.getMessage()), e);
            return createErrorResponse(500, "Internal Server Error", "Failed to update product");
        }
    }

    @Tracing
    private APIGatewayV2HTTPResponse handleDeleteProduct(APIGatewayV2HTTPEvent request, Context context) {
        try {
            String path = request.getRequestContext().getHttp().getPath();
            String normalizedPath = path;
            if (path != null && path.startsWith("/prod/")) {
                normalizedPath = path.substring(5); // Remove "/prod"
            }
            String productId = extractProductIdFromPath(normalizedPath);
            if (productId == null) {
                LOGGER.warn("Product ID validation failed in delete", 
                    Map.of("operation", "deleteProduct",
                           "error", "invalid_product_id",
                           "path", normalizedPath));
                return createErrorResponse(400, "Bad Request", "Product ID is required");
            }

            MDC.put("productId", productId);
            LOGGER.info("Deleting product", 
                Map.of("operation", "deleteProduct",
                       "productId", productId));

            boolean deleted = productService.deleteProduct(productId);
            if (!deleted) {
                LOGGER.warn("Product not found for deletion", 
                    Map.of("operation", "deleteProduct",
                           "productId", productId,
                           "result", "not_found"));
                return createErrorResponse(404, "Not Found", "Product not found");
            }

            LOGGER.info("Product deleted successfully", 
                Map.of("operation", "deleteProduct",
                       "productId", productId,
                       "result", "success"));
            return createSuccessResponse(204, null);

        } catch (IllegalArgumentException e) {
            LOGGER.warn("Validation error in delete request", 
                Map.of("operation", "deleteProduct",
                       "error", "validation_error",
                       "errorMessage", e.getMessage()));
            return createErrorResponse(400, "Bad Request", e.getMessage());
        } catch (Exception e) {
            MDC.put("error", e.getClass().getSimpleName());
            LOGGER.error("Error deleting product", 
                Map.of("operation", "deleteProduct",
                       "error", e.getClass().getSimpleName(),
                       "errorMessage", e.getMessage()), e);
            return createErrorResponse(500, "Internal Server Error", "Failed to delete product");
        }
    }

    private String extractProductIdFromPath(String path) {
        // Expected path format: /products/{id}
        if (path == null || !path.startsWith("/products/")) {
            return null;
        }

        String[] pathParts = path.split("/");
        if (pathParts.length >= 3) {
            return pathParts[2];
        }

        return null;
    }

    private APIGatewayV2HTTPResponse createSuccessResponse(int statusCode, Object body) {
        Map<String, String> headers = createCorsHeaders();

        APIGatewayV2HTTPResponse response = new APIGatewayV2HTTPResponse();
        response.setStatusCode(statusCode);
        response.setHeaders(headers);

        if (body != null) {
            try {
                response.setBody(OBJECT_MAPPER.writeValueAsString(body));
            } catch (JsonProcessingException e) {
                // Fallback to error response if serialization fails
                return createErrorResponse(500, "Internal Server Error", "Failed to serialize response");
            }
        }

        return response;
    }

    private APIGatewayV2HTTPResponse createErrorResponse(int statusCode, String error, String message) {
        Map<String, String> headers = createCorsHeaders();
        ErrorResponse errorResponse = new ErrorResponse(error, message);

        try {
            APIGatewayV2HTTPResponse response = new APIGatewayV2HTTPResponse();
            response.setStatusCode(statusCode);
            response.setHeaders(headers);
            response.setBody(OBJECT_MAPPER.writeValueAsString(errorResponse));
            return response;
        } catch (JsonProcessingException e) {
            // Last resort fallback
            APIGatewayV2HTTPResponse response = new APIGatewayV2HTTPResponse();
            response.setStatusCode(500);
            response.setHeaders(headers);
            response.setBody("{\"error\":\"Internal Server Error\",\"message\":\"Failed to serialize error response\"}");
            return response;
        }
    }

    private Map<String, String> createCorsHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        headers.put("Access-Control-Allow-Origin", "*");
        headers.put("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        headers.put("Access-Control-Allow-Headers", "Content-Type, Authorization");
        return headers;
    }
}